---
title: "Lecture 2.4: Searching in a List"
format:
    revealjs:
        incremental: true
        slideNumber: true
        smaller: true
        center: true
        scrollable: true
---

## Search problem

:::: {.columns}

::: {.column width=50%}

- Is a value `v` present in a list `l`?
- Naive solution scans the list
- Input size `n`, the length of the list
- Worst case is when `v` is not in `l`
- Worst case complexity is `O(n)`

:::

::: {.column width=50%}

```python
def naivesearch(v, l):
    for x in l:
        if v == x:
            return True
    return False
```

:::

::::

## Searching a sorted list

:::: {.columns}

::: {.column width=50%}

- What if `l` is sorted in ascending order?
- Compare `v` with the midpoint of `l`
  - If midpoint is `v`, the value is found
  - If `v` is less than midpoint, search the first half
  - If `v` greater than midpoint, search the second half
  - Stop when the interval to search becomes empty

:::

::: {.column width=50%}

```python
def binarysearch(v, l):
    if l == []:
        return False
    m = len(l) // 2
    if v == l[m]:
        return True
    if v < l[m]:
        return binarysearch(v, l[:m])
    else:
        return binarysearch(v, l[m+1:])
```

:::

::::

## Binary search

- How long does this take?
  - Each call halves the interval to search
  - Stop when the interval becomes empty
- $\log n$ - number of times to divide $n$ by 2 to reach 1
  - $1//2 =0$, so next call reaches empty interval
- $O(\log n)$ steps

## Alternative calculation

:::: {.columns}

::: {.column width=60%}

- $T(n)$: the time to search a list of length $n$
  - If $n=0$, we exit, so $T(0) = 1$
  - If $n>0$, $T(n)=T(n//2)+1$
- Recurrence for $T(n)$
  - $T(0) = 1$
  - $T(n) = T(n//2) + 1$, $n>0$
- Solve by "unwinding"
$$\begin{aligned}
T( n) & =\ T( n//2) +1\\
 & =\ ( T( n//4) +1) +1=\ T\left( n//2^{2}\right) +\underbrace{1+1}_{2}\\
 & =\ \dotsc \\
 & =\ T\left( n//2^{k}\right) +\underbrace{1+\dots +1} _{k}\\
 & =\ T( 1) +k,\ \text{for} \ k=\log n\\
 & =\ ( T( 0) +1) +\log n\\
 & =\ 2+\log n
\end{aligned}$$

:::

::: {.column width=40%}

```python
def bsearch(v, l):
    if l == []:
        return False
    m = len(l) // 2
    if v == l[m]:
        return True
    if v < l[m]:
        return bsearch(v, l[:m])
    else:
        return bsearch(v, l[m+1:])
```

:::

::::

## Summary

- Search in an unsorted list takes time $O(n)$
  - Need to scan the entire list
  - Worst case is when the value is not in the list
- For a sorted list, binary search takes time $O(\log n)$
  - Halve the interval to search each time
- In a sorted list, we can determine that `v` is absent by examining just $\log n$ values!